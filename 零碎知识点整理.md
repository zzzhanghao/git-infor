# 零碎知识点



## 数组相关

### 1、splice方法和slice方法

-  **`splice()`** 方法通过删除或**替换现有元素或者原地添加**新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。 

```javascript
const months = ['Jan', 'March', 'April', 'June'];
months.splice(1, 0, 'Feb');
// inserts at index 1
console.log(months);
// expected output: Array ["Jan", "Feb", "March", "April", "June"]

months.splice(4, 1, 'May');
// replaces 1 element at index 4
console.log(months);
// expected output: Array ["Jan", "Feb", "March", "April", "May"]
```

**[返回值]**

由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。

**[从第 0 位开始删除 2 个元素，插入"parrot"、"anemone"和"blue"]**

```javascript
var myFish = ['angel', 'clown', 'trumpet', 'sturgeon'];
var removed = myFish.splice(0, 2, 'parrot', 'anemone', 'blue');

// 运算后的 myFish: ["parrot", "anemone", "blue", "trumpet", "sturgeon"]
// 被删除的元素: ["angel", "clown"]
```

[**从第 2 位开始删除 2 个元素]**

```java
var myFish = ['parrot', 'anemone', 'blue', 'trumpet', 'sturgeon'];
var removed = myFish.splice(myFish.length - 3, 2);

// 运算后的 myFish: ["parrot", "anemone", "sturgeon"]
// 被删除的元素: ["blue", "trumpet"]
```

**[从倒数第 2 位开始删除 1 个元素]**

```javascript
var myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];
var removed = myFish.splice(-2, 1);

// 运算后的 myFish: ["angel", "clown", "sturgeon"]
// 被删除的元素: ["mandarin"]
```

**[从第 2 位开始删除所有元素]**

```javascript
var myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];
var removed = myFish.splice(2);

// 运算后的 myFish: ["angel", "clown"]
// 被删除的元素: ["mandarin", "sturgeon"]
```





- **slice()** 方法返回一个新的数组对象，这一对象是一个由 `begin` 和 `end` 决定的原数组的**浅拷贝**（包括 `begin`，不包括`end`）。原始数组不会被改变。 记住这个浅拷贝是只有第一层进行深拷贝，

```javascript
const animals = ['ant', 'bison', 'camel', 'duck', 'elephant'];

console.log(animals.slice(2));
// expected output: Array ["camel", "duck", "elephant"]

console.log(animals.slice(2, 4));
// expected output: Array ["camel", "duck"]

console.log(animals.slice(1, 5));
// expected output: Array ["bison", "camel", "duck", "elephant"]
```

**[返回现有数组的一部分]**

```java
//这个就说明是 第一层是深拷贝，slice不会改变原有数组
var fruits = ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango'];
var citrus = fruits.slice(1, 3);

// fruits contains ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango']
// citrus contains ['Orange','Lemon']
```

* 关于slice 是第一层深拷贝的问题

  ```javascript
  const originArray = [1,2,3,4,5];
  const cloneArray = originArray.slice();
  
  console.log(cloneArray === originArray); // false
  cloneArray.push(6); // [1,2,3,4,5,6]
  //给拷贝的数组添加，不会改变原始数组，说明是深拷贝
  console.log(originArray); [1,2,3,4,5];
  ```

  同样地，我们试试多层的数组。

  ```javascript
  const originArray = [1,[1,2,3],{a:1}];
  const cloneArray = originArray.slice();
  console.log(cloneArray === originArray); // false
  cloneArray[1].push(4);
  cloneArray[2].a = 2; 
  //可以看到，只有第一层的1是深拷贝，但是对于多层的数组[1,2,3]和对象{a：1} 他只会拷贝引用地址，所以改变克隆之后，原数据里面的 也会改变
  console.log(originArray); // [1,[1,2,3,4],{a:2}]
  ```



### 2、join方法

`**join()**` 方法将一个数组（或一个[类数组对象](https://developer.mozilla.org/zh-CN//docs/Web/JavaScript/Guide/Indexed_collections#Working_with_array-like_objects)）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。

<iframe class="interactive interactive-js" frameborder="0" height="250" src="https://interactive-examples.mdn.mozilla.net/pages/js/array-join.html" title="MDN Web Docs Interactive Example" width="100%" loading="lazy" style="box-sizing: border-box; background-color: rgb(238, 238, 238); border: 1px solid rgb(234, 242, 244); color: rgb(33, 33, 33); height: 490px; padding: 10px; width: 1002px;"></iframe>

**[语法]**

```
arr.join([separator])
```

**参数**

- `separator` 可选

  指定一个字符串来分隔数组的每个元素。如果需要，将分隔符转换为字符串。如果缺省该值，数组元素用逗号（`,`）分隔。如果`separator`是空字符串(`""`)，则所有元素之间都没有任何字符。

- 返回值

  一个所有数组元素连接的字符串。如果 `arr.length` 为0，则返回空字符串。

**[描述]**

所有的数组元素被转换成字符串，再用一个分隔符将这些字符串连接起来。

如果一个元素为 `undefined` 或 `null`，它会被转换为空字符串。

**[示例]**

**[使用四种不同的分隔符连接数组元素]**

下例首先创建了一个数组 `a`，包含有三个元素，然后用四种不同的分隔符连接所有数组元素。首先是默认的分隔符逗号，然后是一个逗号加空格，接下来是一个加号前后加空格，最后是一个空字符串。

```
var a = ['Wind', 'Rain', 'Fire'];
var myVar1 = a.join();      // myVar1的值变为"Wind,Rain,Fire"
var myVar2 = a.join(', ');  // myVar2的值变为"Wind, Rain, Fire"
var myVar3 = a.join(' + '); // myVar3的值变为"Wind + Rain + Fire"
var myVar4 = a.join('');    // myVar4的值变为"WindRainFire"
```

**[连接类数组对象]**

下面的示例将连接类数组对象（arguments），通过在`Array.prototype.join`上调用[`Function.prototype.call`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call)。

```
function f(a, b, c) {
  var s = Array.prototype.join.call(arguments);
  console.log(s); // '1,a,true'
}
f(1, 'a', true);
```



### 3、push、unshift



![1617674384(1)](https://z3.ax1x.com/2021/04/06/clQf9P.png)



**1、push()、pop()和unshift()、shift()**

　　联系：这两组同为对数组的操作，并且会改变数组的本身的长度及内容。

　　区别：不同的是 push()、pop() 是从数组的尾部进行增减，unshift()、shift() 是从数组的头部进行增减。

```javascript
var arr = [1, 2];
```

**2、push()和unshift()**

　　向数组的 尾部/头部 ***添加若干元素\***，并返回 数组的 **新长度**；返回值是**数组的新长度**

```javascript
arr.push(3,4)；         //返回 arr 的新长度 4 　　
arr ;                   // arr = [1,2,3,4]; 　　
arr.unshift(0,0.5);    // 返回 arr 的新长度 6 　　
arr ;                       // arr = [0,0.5,1,2,3,4];
```

**3、pop()和shift()**

　　从数组的 尾部/头部 ***删除1个元素(删且只删除1个)\***，并返回 **被删除的元素**；空数组是继续删除，不报错，但返回undefined；

```javascript
arr.pop();　　　　　　//返回 4； 　　
arr ;　　　　　　　　  // arr = [0,0.5,1,2,3]; 　　	
arr.pop();　　　　　　//返回 3； 　　
arr ;　　　　　　　　 // arr = [0,0.5,1,2]; 　　	
arr.shift()；　　　　  // 返回 0 ； 　　
arr ;　　　　　　　　// arr = [0.5,1,2]
```

　　**PS:** pop()和shift() 不接受传参，即使传了参数也没什么卵用~~；

```javascript
arr.pop(3) ;           // 返回 2；永远返回最后一个； 　　
arr ; 　　　　　　　// arr = [0.5,1]; 　　
arr.shift(1);　　　　// 返回 0.5; 永远返回第一个； 　　
arr ;　　　　　　　　// arr = [1]; 　　
arr.pop() ; 　　　　// 返回 1； 　　
arr ;　　　　　　　　// arr = []; 　　
arr.shift()　　　　　// 返回 undefined； 　　
arr ;　　　　　　　　// arr = [];
```



**注：  unshift方法是会改变 数组的原始索引的**

### 4、Array.prototype.every()

`**every()**` 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。

**注意**：若收到一个空数组，此方法在一切情况下都会返回 `true`。

<iframe class="interactive" width="100%" height="490" src="https://interactive-examples.mdn.mozilla.net/pages/js/array-every.html" title="MDN Web Docs Interactive Example" loading="lazy" style="box-sizing: border-box; background-color: rgb(238, 238, 238); border: 0px; color: rgb(33, 33, 33); padding: 10px; width: 1002px;"></iframe>

**[语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every#语法)**

```
arr.every(callback(element[, index[, array]])[, thisArg])
```

**[参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every#参数)**

- `callback`

  用来测试每个元素的函数，它可以接收三个参数：`element`用于测试的当前值。`index`可选用于测试的当前值的索引。`array`可选调用 `every` 的当前数组。

- `thisArg`

  执行 `callback` 时使用的 `this` 值。

**[返回值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every#返回值)**

如果回调函数的每一次返回都为 [truthy](https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy) 值，返回 `**true**` ，否则返回 `**false**`。



**[例子](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every#例子)**

**[检测所有数组元素的大小](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every#检测所有数组元素的大小)**

下例检测数组中的所有元素是否都大于 10。

```
function isBigEnough(element, index, array) {
  return element >= 10;
}
[12, 5, 8, 130, 44].every(isBigEnough);   // false
[12, 54, 18, 130, 44].every(isBigEnough); // true
```

**[使用箭头函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every#使用箭头函数)**

[箭头函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions)为上面的检测过程提供了更简短的语法。

```
[12, 5, 8, 130, 44].every(x => x >= 10); // false
[12, 54, 18, 130, 44].every(x => x >= 10); // true
```

### 5、Array.prototype.reduce() ，看文档

`**reduce()**` 方法对数组中的每个元素执行一个由您提供的**reducer**函数(升序执行)，将其结果汇总为单个返回值。

<iframe class="interactive" width="100%" height="490" src="https://interactive-examples.mdn.mozilla.net/pages/js/array-reduce.html" title="MDN Web Docs Interactive Example" loading="lazy" style="box-sizing: border-box; background-color: rgb(238, 238, 238); border: 0px; color: rgb(33, 33, 33); padding: 10px; width: 1002px;"></iframe>

**reducer** 函数接收4个参数:

1. Accumulator (acc) (累计器)
2. Current Value (cur) (当前值)
3. Current Index (idx) (当前索引)
4. Source Array (src) (源数组)

您的 **reducer** 函数的返回值分配给累计器，该返回值在数组的每个迭代中被记住，并最后成为最终的单个结果值。

**[语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#语法)**

```
arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])
```

**[参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#参数)**

- `callback`

  执行数组中每个值 (如果没有提供 `initialValue则第一个值除外`)的函数，包含四个参数：

  **`accumulator`**累计器累计回调的返回值; 它是上一次调用回调时返回的累积值，或`initialValue`（见于下方）。`currentValue`数组中正在处理的元素。`index` 可选数组中正在处理的当前元素的索引。 如果提供了`initialValue`，则起始索引号为0，否则从索引1起始。`array`可选调用`reduce()`的数组

- `initialValue`可选

  作为第一次调用 `callback`函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。

**[返回值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#返回值)**

函数累计处理的结果

**[描述](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#描述)**

`reduce`为数组中的每一个元素依次执行`callback`函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：

- `accumulator 累计器`
- `currentValue 当前值`
- `currentIndex 当前索引`
- `array 数组`

回调函数第一次执行时，`accumulator` 和`currentValue`的取值有两种情况：如果调用`reduce()`时提供了`initialValue`，`accumulator`取值为`initialValue`，`currentValue`取数组中的第一个值；如果没有提供 `initialValue`，那么`accumulator`取数组中的第一个值，`currentValue`取数组中的第二个值。

**注意：**如果没有提供`initialValue`，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供`initialValue`，从索引0开始。

如果数组为空且没有提供`initialValue`，会抛出[`TypeError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError) 。如果数组仅有一个元素（无论位置如何）并且没有提供`initialValue`， 或者有提供`initialValue`但是数组为空，那么此唯一值将被返回并且`callback`不会被执行。

提供初始值通常更安全，正如下面的例子，如果没有提供`initialValue`，则可能有四种输出：

```javascript
var maxCallback = ( acc, cur ) => Math.max( acc.x, cur.x );
var maxCallback2 = ( max, cur ) => Math.max( max, cur );

// reduce() 没有初始值
[ { x: 2 }, { x: 22 }, { x: 42 } ].reduce( maxCallback ); // NaN
[ { x: 2 }, { x: 22 }            ].reduce( maxCallback ); // 22
[ { x: 2 }                       ].reduce( maxCallback ); // { x: 2 }
[                                ].reduce( maxCallback ); // TypeError

// map/reduce; 这是更好的方案，即使传入空数组或更大数组也可正常执行
[ { x: 22 }, { x: 42 } ].map( el => el.x )
                        .reduce( maxCallback2, -Infinity );
```

**[reduce() 如何运行](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#reduce_如何运行)**

假如运行下段`reduce()`代码：

```java
[0, 1, 2, 3, 4].reduce(function(accumulator, currentValue, currentIndex, array){
  return accumulator + currentValue;
});
```

callback 被调用四次，每次调用的参数和返回值如下表：

​	由`reduce`返回的值将是最后一次回调返回值（10）。

你还可以使用[箭头函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions)来代替完整的函数。 下面的代码将产生与上面的代码相同的输出：

```
[0, 1, 2, 3, 4].reduce((prev, curr) => prev + curr );
```

如果你打算提供一个初始值作为`reduce()`方法的第二个参数，以下是运行过程及结果：

```
[0, 1, 2, 3, 4].reduce((accumulator, currentValue, currentIndex, array) => {
    return accumulator + currentValue
}, 10)
```















### 6、Array.prototype.includes()

 

`**includes()**` 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。

<iframe class="interactive" width="100%" height="490" src="https://interactive-examples.mdn.mozilla.net/pages/js/array-includes.html" title="MDN Web Docs Interactive Example" loading="lazy" style="box-sizing: border-box; background-color: rgb(238, 238, 238); border: 0px; color: rgb(33, 33, 33); padding: 10px; width: 1002px;"></iframe>

**[语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes#语法)**

```
arr.includes(valueToFind[, fromIndex])
```

**[参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes#参数)**

- `valueToFind`

  需要查找的元素值。**Note:** 使用 `includes()`比较字符串和字符时是区分大小写。

- `fromIndex` 可选

  从`fromIndex` 索引处开始查找 `valueToFind`。如果为负值，则按升序从 `array.length + fromIndex` 的索引开始搜 （即使从末尾开始往前跳 `fromIndex` 的绝对值个索引，然后往后搜寻）。默认为 0。

**[返回值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes#返回值)**

A [`Boolean`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean) which is `true` if the value `valueToFind` is found within the array (or the part of the array indicated by the index `fromIndex`, if specified). Values of zero are all considered to be equal regardless of sign (that is, -0 is considered to be equal to both 0 and +0), but `false` is not considered to be the same as 0.

返回一个布尔值 [`Boolean`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean) ，如果在数组中找到了（如果传入了 `fromIndex` ，表示在 `fromIndex` 指定的索引范围中找到了）则返回 `true` 。

**Note:** Technically speaking, `includes()` uses the `sameValueZero` algorithm to determine whether the given element is found.

**[示例](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes#示例)**

```
[1, 2, 3].includes(2);     // true
[1, 2, 3].includes(4);     // false
[1, 2, 3].includes(3, 3);  // false
[1, 2, 3].includes(3, -1); // true
[1, 2, NaN].includes(NaN); // true
```





### 7、String.prototype.includes

**`includes()`** 方法用于判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false。

**[语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/includes#syntax)**

```
str.includes(searchString[, position])
```

**[参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/includes#参数)**

- `searchString`

  要在此字符串中搜索的字符串。

- `position` 可选

  从当前字符串的哪个索引位置开始搜寻子字符串，默认值为 `0`。

- 返回值

  如果当前字符串包含被搜寻的字符串，就返回 **`true`**；否则返回 **`false`**。

**[描述](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/includes#描述)**

这个方法可以帮你判断一个字符串是否包含另外一个字符串。

**[区分大小写](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/includes#区分大小写)**

`includes()` 方法是区分大小写的。例如，下面的表达式会返回 **`false`** ：

```
'Blue Whale'.includes('blue'); // returns false
```

**[示例](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/includes#examples)**

```javascript
var str = 'To be, or not to be, that is the question.';

console.log(str.includes('To be'));       // true
console.log(str.includes('question'));    // true
console.log(str.includes('nonexistent')); // false
console.log(str.includes('To be', 1));    // false
console.log(str.includes('TO BE'));       // false
```



### 8、js定义二维数组



```javascript
var data = new Array();
for (var i = 0; i < 5; i++) {
 data[i] = new Array();

 for (var j = 0; j < 2; j++) {
  data[i][j] = 1;
 }

}

console.log(data);    //五行两列的二维数组
```

























































## 其他



### 1、 js for循环  for in for of



**for in**

```javascript
这个是常规的 循环
for (var i=0; i<5; i++) {     
 	x=x + "该数字为 " + i + "<br>"; 
 } 
```

for-in： 首先for in最多的是用在了 循环遍历**对象**的属性： 

var person={fname:"Bill",lname:"Gates",age:56}; 

for (x in person)  // x 为属性名
{
   consol.log(x);
}
x 输出 fname lname age

但是一定要注意 for in 用在数组里面就是 遍历索引了

```javascript

var str = ['num1','num2']
for(let s in str){
 console.log(s);
}
1 2
```



**for of**

**Arrays(数组)**

Arrays（数组）就是类列表（list-like）对象。数组原型上有各种方法，允许对其进行操作，比如修改和遍历等操作。下面手在一个数组上进行的 `for...of` 操作：

```javascript
// array-example.js
const iterable = ['mini', 'mani', 'mo'];
 
for (const value of iterable) {
  console.log(value);
}
 
// Output:
// mini
// mani
// mo
```

其结果就是打印出 `iterable` 数组中的每一个值。

**普通对象不可迭代**

`for...of` 循环仅适用于迭代。 而普通对象不可迭代。 我们来看一下：

```javascript
const obj = { fname: 'foo', lname: 'bar' };
 
for (const value of obj) { // TypeError: obj[Symbol.iterator] is not a function
    console.log(value);
}
```

在这里，我们定义了一个普通对象 `obj` ，并且当我们尝试 `for...of` 对其进行操作时，会报错：`TypeError: obj[Symbol.iterator] is not a function`。



我们可以通过将类数组(array-like)对象转换为数组来绕过它。该对象将具有一个 `length` 属性，其元素必须可以被索引。我们来看一个例子：

```javascript
// object-example.js
const obj = { length: 3, 0: 'foo', 1: 'bar', 2: 'baz' };
 
const array = Array.from(obj);
for (const value of array) { 
    console.log(value);
}
// Output:
// foo
// bar
// baz
```

`Array.from()` 方法可以让我通过类数组(array-like)或可迭代对象来创建一个新的 Array(数组) 实例







### 2、Object.assign()

`**Object.assign()**` 方法用于将所有可枚举属性的值从一个或多个源**对象**分配到目标**对象**。它将返回目标对象。

<iframe class="interactive interactive-js" frameborder="0" height="250" src="https://interactive-examples.mdn.mozilla.net/pages/js/object-assign.html" title="MDN Web Docs Interactive Example" width="100%" loading="lazy" style="box-sizing: border-box; background-color: rgb(238, 238, 238); border: 1px solid rgb(234, 242, 244); color: rgb(33, 33, 33); height: 490px; padding: 10px; width: 1098px;"></iframe>
**语法**

```
Object.assign(target, ...sources)
```

**[参数](https://developer.mozilla.org/zh-cn/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#parameters)**

- `target`

  目标对象。

- `sources`

  源对象。

**[返回值](https://developer.mozilla.org/zh-cn/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#return_value)**

目标对象。

**[描述](https://developer.mozilla.org/zh-cn/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#描述)**

如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性。

`Object.assign` 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的`[[Get]]`和目标对象的`[[Set]]`，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用[`Object.getOwnPropertyDescriptor()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor)和[`Object.defineProperty()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) 。

[`String`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/String)类型和 [`Symbol`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol) 类型的属性都会被拷贝。

在出现错误的情况下，例如，如果属性不可写，会引发[`TypeError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError)，如果在引发错误之前添加了任何属性，则可以更改`target`对象。

**[示例](https://developer.mozilla.org/zh-cn/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#examples)**

[复制一个对象](https://developer.mozilla.org/zh-cn/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#example_cloning_an_object)

```
const obj = { a: 1 };
const copy = Object.assign({}, obj);
console.log(copy); // { a: 1 }
```

**[深拷贝问题](https://developer.mozilla.org/zh-cn/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#deep_clone)**

针对深拷贝，需要使用其他办法，因为 `Object.assign()`拷贝的是（可枚举）属性值。

假如源值是一个对象的引用，它仅仅会复制其引用值。

```javascript
const log = console.log;

function test() {
  'use strict';
  let obj1 = { a: 0 , b: { c: 0}};
  let obj2 = Object.assign({}, obj1);
  log(JSON.stringify(obj2));
  // { a: 0, b: { c: 0}}

  obj1.a = 1;
  log(JSON.stringify(obj1));
  // { a: 1, b: { c: 0}}
  log(JSON.stringify(obj2));
  // { a: 0, b: { c: 0}}

  obj2.a = 2;
  log(JSON.stringify(obj1));
  // { a: 1, b: { c: 0}}
  log(JSON.stringify(obj2));
  // { a: 2, b: { c: 0}}

  obj2.b.c = 3;
  log(JSON.stringify(obj1));
  // { a: 1, b: { c: 3}}
  log(JSON.stringify(obj2));
  // { a: 2, b: { c: 3}}

  // Deep Clone
  obj1 = { a: 0 , b: { c: 0}};
  let obj3 = JSON.parse(JSON.stringify(obj1));
  obj1.a = 4;
  obj1.b.c = 4;
  log(JSON.stringify(obj3));
  // { a: 0, b: { c: 0}}
}

test();
```

**[合并对象](https://developer.mozilla.org/zh-cn/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#example_merging_objects)**

```
const o1 = { a: 1 };
const o2 = { b: 2 };
const o3 = { c: 3 };

const obj = Object.assign(o1, o2, o3);
console.log(obj); // { a: 1, b: 2, c: 3 }
console.log(o1);  // { a: 1, b: 2, c: 3 }, 注意目标对象自身也会改变。
```

**[合并具有相同属性的对象](https://developer.mozilla.org/zh-cn/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#合并具有相同属性的对象)**

```
const o1 = { a: 1, b: 1, c: 1 };
const o2 = { b: 2, c: 2 };
const o3 = { c: 3 };

const obj = Object.assign({}, o1, o2, o3);
console.log(obj); // { a: 1, b: 2, c: 3 }
```

属性被后续参数中具有相同属性的其他对象覆盖。

**[拷贝 symbol 类型的属性](https://developer.mozilla.org/zh-cn/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#example_symbol_properties)**

```
const o1 = { a: 1 };
const o2 = { [Symbol('foo')]: 2 };

const obj = Object.assign({}, o1, o2);
console.log(obj); // { a : 1, [Symbol("foo")]: 2 } (cf. bug 1207182 on Firefox)
Object.getOwnPropertySymbols(obj); // [Symbol(foo)]
```

**[继承属性和不可枚举属性是不能拷贝的](https://developer.mozilla.org/zh-cn/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#example_only_own_enumerable_properties)**

```
const obj = Object.create({foo: 1}, { // foo 是个继承属性。
    bar: {
        value: 2  // bar 是个不可枚举属性。
    },
    baz: {
        value: 3,
        enumerable: true  // baz 是个自身可枚举属性。
    }
});

const copy = Object.assign({}, obj);
console.log(copy); // { baz: 3 }
```

**[原始类型会被包装为对象](https://developer.mozilla.org/zh-cn/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#example_primitives)**

```
const v1 = "abc";
const v2 = true;
const v3 = 10;
const v4 = Symbol("foo")

const obj = Object.assign({}, v1, null, v2, undefined, v3, v4);
// 原始类型会被包装，null 和 undefined 会被忽略。
// 注意，只有字符串的包装对象才可能有自身可枚举属性。
console.log(obj); // { "0": "a", "1": "b", "2": "c" }
```







### 3、js 变量提升、this、new



**js超经典面试题Foo.getName()的故事**



**下面是一道超经典的JS面试题。
蕴含了静态属性与实例属性，变量提升，this指向，new一个函数的过程**

```javascript
function Foo() {
    getName = function () {
        console.log(1);
    };
    return this;
};
Foo.getName = function () {
    console.log(2);
};
Foo.prototype.getName = function () {
    console.log(3);
};
var getName = function () {
    console.log(4);
};
function getName() {
    console.log(5);
};

Foo.getName(); 
getName(); 
Foo().getName(); 
getName(); 
new Foo.getName();
new Foo().getName();
new new Foo().getName(); 
复制代码
```

**输出一下结果**

```javascript
Foo.getName(); //2
getName(); //4
Foo().getName(); //1
getName(); //1
new Foo.getName(); //2
new Foo().getName(); //3
new new Foo().getName(); //3
复制代码
```

**一、解析：**
1.Foo.getName()

> 我们先看此题的上半部分做了什么，首先定义了一个叫Foo的函数，之后为Foo创建了一个叫getName的静态属性存储了一个匿名函数，之后为Foo的原型对象新创建了一个叫getName的匿名函数。之后又通过函数变量表达式创建了一个getName的函数，最后再声明一个叫getName函数。

第一问的 Foo.getName 自然是访问Foo函数上存储的静态属性，自然是2

**二、解析：**
2.getName()

> 为何输出是4，这里考的是变量提升与函数声明提升。我们知道使用var声明变量会存在变量提升的情况，比如下面的例子中，即使在声明前使用变量a也不会报错，举例：

```javascript
console.log(a)// undefined
var a = 1;
console.log(a)// 1
复制代码
```

> 因为声明提前会让声明提升到代码的最上层，而赋值操作停留在原地，所以上面代码等同于：

```javascript
var a
console.log(a)// undefined
a = 1;
console.log(a)// 1
复制代码
```

> 而函数声明（注意是函数声明，不是函数表达式或者构造函数创建函数）也会存在声明提前的情况，即我们可以在函数声明前调用函数：

```javascript
fn() // 1
function fn() {
    console.log(1);
};
fn() // 1

//因为函数声明提前，导致函数声明也会被提到代码顶端，所以等同于
function fn() {
    console.log(1);
};
fn() // 1
fn() // 1
复制代码
```

> 那这样就存在一个问题了，变量声明会提升，函数声明也会提升，谁提升的更高呢？在你不知道的JavaScript中明确指出，函数声明会被优先提升，也就是说都是提升，但是函数比变量提升更高，所以题目中的两个函数顺序可以改写成：

```javascript
function getName() {
    console.log(5);
};

var getName;

getName = function () {
    console.log(4);
};

复制代码
```

这样就解释了为什么是输出4。

**三、解析：**
3.Foo().getName()

> 其实可以看出来，我们在执行Foo()函数的时候getName这个变量提升到外部的全局作用域中了，因为在js中，如果对于一个变量没用用var 或者 let等声明的话，他就默认是全局属性,就是window对象的一个属性。所以在这里我们的全局的getName又被改了
> 因为我们Foo()执行的时候返回了this而这里的this就是window对象 我们需要知道的是在浏览器中所有全局的声明都是window对象的属性和方法，所以这里我们调用this.getName()就会返回1了。

**四、解析：**
4.getName()

> 这里输出1已经毫无悬念，上一分析中，getName的值在Foo执行时被修改了，所以再调用getName一样等同于window.getName()，同样是输出1。

**五、解析：**
5.new Foo.getName()

> 首先还是先看运算符优先级吧，我自个看完的结果是【new Foo() > Foo() > new Foo】，先运算方式2的Foo.getName() 结果为“2”，再new一个Foo实例对象,因此这里new的过程就相当于单纯把Foo.getName执行了一遍输出2。

**六、解析：**
6.new Foo().getName()

> 这里考了new基本概念，首先这个调用分为两步，第一步new Foo()得到一个实例，第二步调用实例的getName方法。

> 我们知道new一个构造函数的过程大致为，以构造函数原型创建一个对象（继承原型链），调用构造函数并将this指向这个新建的对象，好让对象继承构造函数中的构造器属性，如果构造函数没有手动返回一个对象，则返回这个新建的对象。

> 所以在执行new Foo()时，先以Foo原型创建了一个对象，由于Foo.prototype上事先设置了一个getName方法（输出3的那个），所以这个对象可通过原型访问到这个方法，其次由于Foo内部也没提供什么构造器属性，最终返回了一个this（这个this指向实例），因此这里的this还是等同于我们前面概念提到的以Foo原型创建的对象，可以尝试输出这个实例，除了原型上有一个getName方法就没有其它任何属性，因此这里输出3。

**七、解析：**
7.new new Foo().getName()

> 相当于new(new Foo().getName()) 先执行new Foo().getName()由6部知道了输出3，再创建Foo.prototype.getName()的实例返回。结果为3





### 4、js 次方开方



Math.pow(3,2);  3的平方

Math.Pow(2,3);  2的立方

 

开方Math.sqrt(值)

如:

Math.sqrt(9);  9 开方，返回结果3









### 5、js对象的属性获取方式





[js 通过对象属性名称获取属性值的注意要点](https://www.cnblogs.com/ronghua/p/13164125.html)

**1、不能是变量**

```javascript
var obj = {}; 
obj.AttrName = 'Tom'
```

注意：通过 **对象.属性名** 获取属性值的时候，属性名（AttrName ）不能是一个变量。　　

**2、可以是变量**

原始数据数组：

```javascript
var rawDataList =
[
    {
        "countDate": "2018-04-08",
        "countNum": "2"
    },
    {
        "countDate": "2018-04-18",
        "countNum": "2"
    },
    {
        "countDate": "2018-04-23",
        "countNum": "7"
    }
 ]
```

处理上述数据：

```javascript
function Day2Mon2Year(dataList,prop){
  for(var i = 0; i < dataList.length; i++){
      var obj = rawDataList[i]
      //报错：Uncaught TypeError: Cannot read property 'replace' of undefined
      var dateAttr = obj.prop
      //不报错：因为prop是变量，获取方式不能是通过.属性名称
      var dateAttr = obj[prop]
  }
}
//调用报错：Uncaught TypeError: Cannot read property 'replace' of undefined
Day2Mon2Year.(rawDataList,'countDate');
```

**3、总结：**

下面这个是重点，一般就直接用 第二种方式吧



一、如果属性名称是`常量`（固定值），获取属性值的方式有：

- `对象.属性名称`
- `对象[属性名称]`

二、如果属性名称是一个`变量`（不固定值），获取属性值方式只能是：

- `对象[属性名称]`





### 6、Promise中settimeout使用



**Promise 中 setTimeout 的使用**

```javascript
function getData() {
	return new Promise((resolve, reject) => {
	  setTimeout(resolve('hello'), 2000)
	})
}
getData().then(res => {
  console.log(res)
})
// 立马输出 hello

```



```javascript
// code2

function getData() {
	return new Promise((resolve, reject) => {
	  setTimeout(resolve, 2000, 'hello')
	})
}
getData().then(res => {
  console.log(res)
})
// 2s后输出hello
```



其实呢，这个差异就是 func() 和 func 的区别，setTimeout 的第一个参数是 func，如果用 func() 相当于其返回值为第一个参数。

这个地方应该是一个函数 func ，如果你传的是 func() ，代码解析器执行到此处的时候，就会立即执行这个函数，起不到延时的效果了。

**常见的使用场景**
**实现一个 sleep 函数**

```javascript
// 1s 后执行的代码
const sleep = (time) => {
  return new Promise(resolve => setTimeout(resolve, time))
}

sleep(1000).then(() => {
  // 这里写你的操作
})

```

```javascript
// 代码延时
const sleep = (time) => {
  return new Promise(resolve => setTimeout(resolve, time))
}

async function sleepAsync() {
  console.log('1')
  let res = await sleep(1000)
  console.log('2')
  return res
}

sleepAsync()

```





### 7、前端框架路由实现的Hash和History两种模式的区别

参考https://juejin.cn/post/6844903969886568461

- 之前面试的时候就有准备过前端框架中两种路由实现方式及区别，但是当时没专门下功夫去深入了解，就在网上搜了下别人总结的临时抱了下佛脚。但是事实证明，出来混，总是要还的，在后来的面试中又遇到了，而且这次问得更加深入，仅仅靠死记硬背来的知识总是遗忘得很快，网上别人总结的东西终归还是别人的，鉴于网上别人总结的内容有点杂乱无章，还是决定自己在此总结记录一番，以加深印象。

**一、何为前端路由**

- 路由的概念来自于服务器端，在SPA（单页应用）中，路由描述的是URL到函数的映射关系，即在浏览器中输入一个URL，相应的控制器会对提交的请求进行解析，然后进行路由匹配，找到对应的模块和函数进行执行。

**二、如何实现**

- 实现的两个核心问题是如何检测路由变化和如何改变URL而不刷新页面，通常有两种实现模式，一种是Hash模式，一种是History模式。

**三、Hash模式**

- 早期的前端路由的实现就是基于`location.hash`来实现的，`location.hash`的值就是URL中#后面的内容 其实现原理就是监听#后面的内容来发起Ajax请求来进行局部更新，而不需要刷新整个页面。

- 使用`hashchange`事件来监听 URL 的变化，以下这几种情况改变 URL 都会触发 `hashchange` 事件：浏览器前进后退改变 URL、`<a>`标签改变 URL、window.location改变URL。

  **优缺点**

- 兼容低版本浏览器，Angular1.x和Vue默认使用的就是hash路由

- 只有#符号之前的内容才会包含在请求中被发送到后端，也就是说就算后端没有对路由全覆盖，但是不会返回404错误

- hash值的改变，都会在浏览器的访问历史中增加一个记录，所以可以通过浏览器的回退、前进按钮控制hash的切换

- 会覆盖锚点定位元素的功能

- 不太美观，#后面传输的数据复杂的话会出现问题

**四、History模式**

- history 提供了 `pushState` 和 `replaceState` 两个方法来记录路由状态，这两个方法改变 URL 不会引起页面刷新

- history 提供类似 hashchange 事件的 popstate 事件，但 popstate 事件有些不同：通过浏览器前进后退改变 URL 时会触发 popstate 事件，通过pushState/replaceState或`<a>`标签改变 URL 不会触发 popstate 事件。好在我们可以拦截 pushState/replaceState的调用和`<a>`标签的点击事件来检测 URL 变化，所以监听 URL 变化可以实现，只是没有 hashchange 那么方便。

- `pushState(state, title, url)` 和 `replaceState(state, title, url)`都可以接受三个相同的参数：

- state：需要保存的数据，这个数据在触发popstate事件时，可以在event.state里获取

- title：标题，基本没用，一般传 null

- url：设定新的历史记录的 url，新的 url 与当前 url 的 origin 必须是一样的，否则会抛错，url可以是绝对路径，也可以是相对路径。

  **优缺点**

- 使用简单，比较美观

- `pushState()`设置新的URL可以是任意与当前URL同源的URL，而hash只能改变#后面的内容，因此只能设置与当前URL同文档的URL

- `pushState()`设置的URL与当前URL一模一样时也会被添加到历史记录栈中，而hash#后面的内容必须被修改才会被添加到新的记录栈中

- `pushState()`可以通过`stateObject`参数添加任意类型的数据到记录中，而hash只能添加短字符串

- `pushState()`可额外设置title属性供后续使用

- 前端的URL必须和向发送请求后端URL保持一致，否则会报404错误

- 由于History API的缘故，低版本浏览器有兼容行问题



### 8、vue $router和$route的区别


一、

router为VueRouter的实例，相当于一个全局的路由器对象，里面含有很多属性和子对象，例如history对象。。。经常用的跳转链接就可以用this.$router.push，和router-link跳转一样。。。

this.$router.push会往history栈中添加一个新的记录。。详细见vue官方文档https://router.vuejs.org/zh/guide/essentials/navigation.html

 

route相当于当前正在跳转的路由对象。。可以从里面获取name,path,params,query等。。

打印this.$route和this.$router。

![img](https://img-blog.csdn.net/20180806212532808?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdndW95dTE5OTY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

路由传参的方式

1.可以手写完整的path：

this.$router.push({path:`/user/${userId}`})

这样传递参数的话，配置路由的时候需要在path上加参数path：user/：userId。

这种接收参数的方式是this.$route.params.userId。

2.也可以用params传递：

![img](https://img-blog.csdn.net/20180608211615303?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdndW95dTE5OTY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

3.也可以用query传递：

![img](https://img-blog.csdn.net/20180608211639321?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdndW95dTE5OTY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

query传参是针对path的，params传参是针对name的。。接收参数的方式都差不多。。this.$route.query.和this.$route.params.

注意这只是跳转url，跳转到这个url显示什么组件，得配置路由。router跳转和<router-link>标签跳转，规则差不多。

展示上的话：





### 9、三个点(...)扩展运算符

## 

三个点（...）真名叫扩展运算符，是在ES6中新增加的内容，它可以在函数调用/数组构造时，将数组表达式或者string在语法层面展开；还可以在构造字面量对象时将对象表达式按照key-value的方式展开

> 字面量一般指[1,2,3]或者{name:'chuichui'}这种简洁的构造方式,多层嵌套的数组和对象三个点就无能为力了

说白了就是把衣服脱了，不管是大括号（[]）、花括号（{}），统统不在话下，**全部脱掉脱掉！**

```
// 数组
var number = [1,2,3,4,5,6]
console.log(...number) //1 2 3 4 5 6
//对象
var man = {name:'chuichui',height:176}
console.log({...man}) / {name:'chuichui',height:176}
```

**有什么用？**

它的用处很广泛，我们随处都可以看到，下面是几个常见的例子

**复制用它**

```javascript
//数组的复制
var arr1 = ['hello']
var arr2 =[...arr1]
arr2 // ['hello']
//对象的复制
var obj1 = {name:'chuichui'}
var obj2 ={...arr}
ob12 //  {name:'chuichui'}
```

**合并用它**

```javascript
//数组的合并
var arr1 = ['hello']
var arr2 =['chuichui']
var mergeArr = [...arr1,...arr2]
mergeArr  // ['hello','chuichui']
// 对象分合并
var obj1 = {name:'chuichui'}
var obj2 = {height:176}
var mergeObj = {...obj1,...obj2}
mergeObj // {name: "chuichui", height: 176}
```

**字符转数组用它**

```javascript
var arr1 = [...'hello']
arr1 // ["h", "e", "l", "l", "o"]
```

**函数传参用它**

可以和正常的函数相结合，灵活使用

```javascript
function f(v,w,x,y,z){ }
var args = [2,3]
f(1,...args,4,...[5])
```

当我们想把数组中的元素迭代为函数参数时，用它！

```javascript
function f(x,y,z){}
var args = [1,2,3]
f(...args)
 
// 以前的方法
f.apply(null,args);
```



### 10、js 的数据类型（typeof、instanceof）



**[数据类型](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#数据类型)**

最新的 ECMAScript 标准定义了 9 种数据类型:

- 6 种原始类型，使用typeof运算符检查:
  - [undefined](https://developer.mozilla.org/en-US/docs/Glossary/undefined)：`typeof instance === "undefined"`
  - [Boolean](https://developer.mozilla.org/en-US/docs/Glossary/Boolean)：`typeof instance === "boolean"`
  - [Number](https://developer.mozilla.org/en-US/docs/Glossary/Number)：`typeof instance === "number"`
  - [String](https://developer.mozilla.org/en-US/docs/Glossary/String)：`typeof instance === "string`
  - [BigInt](https://developer.mozilla.org/en-US/docs/Glossary/BigInt)：`typeof instance === "bigint"`
  - [Symbol](https://developer.mozilla.org/en-US/docs/Glossary/Symbol) ：`typeof instance === "symbol"`
- [null](https://developer.mozilla.org/en-US/docs/Glossary/Null)：`typeof instance === "object"`。
- [Object](https://developer.mozilla.org/en-US/docs/Glossary/Object)：`typeof instance === "object"`。任何 [constructed](https://developer.mozilla.org/en-US/docs/Glossary/constructed) 对象实例的特殊非数据结构类型，也用做数据结构：new [Object](https://developer.mozilla.org/en-US/docs/Glossary/Object)，new [Array](https://developer.mozilla.org/en-US/docs/Glossary/array)，new [Map](https://developer.mozilla.org/en-US/docs/Glossary/Map)，new [Set](https://developer.mozilla.org/en-US/docs/Glossary/Set)，new [WeakMap](https://developer.mozilla.org/en-US/docs/Glossary/WeakMap)，new [WeakSet](https://developer.mozilla.org/en-US/docs/Glossary/WeakSet)，new [Date](https://developer.mozilla.org/en-US/docs/Glossary/Date)，和几乎所有通过 [new keyword](https://developer.mozilla.org/en-US/docs/Glossary/new_keyword) 创建的东西。
- [Function](https://developer.mozilla.org/en-US/docs/Glossary/Function)：非数据结构，尽管 typeof 操作的结果是：`typeof instance === "function"`。这个结果是为 Function 的一个特殊缩写，尽管每个 Function 构造器都由 Object 构造器派生。

记住 `typeof` 操作符的唯一目的就是检查数据类型，如果我们希望检查任何从 Object 派生出来的结构类型，使用 `typeof` 是不起作用的，因为总是会得到 `"object"`。检查 Object 种类的合适方式是使用 [instanceof](https://developer.mozilla.org/en-US/docs/Glossary/instanceof) 关键字。但即使这样也存在误差。



  基本类型（单类型）：除Object。 String、Number、boolean、null、undefined。

  引用类型：object。里面包含的 function、Array、Date。

**JS数据类型：JS 中 typeof 输出分别是什么？**

  { } 、[ ] 输出 object。也就是数组 对象都判断为 object

  console.log( ) 输出 function。



**检测数组类型的方法**         

① instanceof  **操作符**

![img](https://img-blog.csdnimg.cn/20190708192500488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM1OTI1NzU=,size_16,color_FFFFFF,t_70)

  ③ Array.isArray( ) 检验值是否为数组

![img](https://img-blog.csdnimg.cn/20190708192500518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM1OTI1NzU=,size_16,color_FFFFFF,t_70)



### 11、typeof 已经一些格式



**`typeof`** 操作符返回一个字符串，表示未经计算的操作数的类型。

<iframe class="interactive interactive-js" width="100%" height="250" src="https://interactive-examples.mdn.mozilla.net/pages/js/expressions-typeof.html" title="MDN Web Docs Interactive Example" loading="lazy" style="box-sizing: border-box; background-color: rgb(238, 238, 238); border: 0px; color: rgb(33, 33, 33); height: 490px; padding: 10px; width: 1002px;"></iframe>



下表总结了 `typeof` 可能的返回值。有关类型和原始值的更多信息，可查看 [JavaScript 数据结构](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures) 页面。



| 类型                                                         | 结果                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [Undefined](https://developer.mozilla.org/en-US/docs/Glossary/undefined) | `"undefined"`                                                |
| [Null](https://developer.mozilla.org/en-US/docs/Glossary/Null) | `"object"` (见[下文](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof#null)) |
| [Boolean](https://developer.mozilla.org/en-US/docs/Glossary/Boolean) | `"boolean"`                                                  |
| [Number](https://developer.mozilla.org/en-US/docs/Glossary/Number) | `"number"`                                                   |
| [BigInt](https://developer.mozilla.org/en-US/docs/Glossary/BigInt)(ECMAScript 2020 新增) | `"bigint"`                                                   |
| [String](https://developer.mozilla.org/en-US/docs/Glossary/String) | `"string"`                                                   |
| [Symbol](https://developer.mozilla.org/en-US/docs/Glossary/Symbol) (ECMAScript 2015 新增) | `"symbol"`                                                   |
| 宿主对象（由 JS 环境提供）                                   | *取决于具体实现*                                             |
| [Function](https://developer.mozilla.org/en-US/docs/Glossary/Function) 对象 (按照 ECMA-262 规范实现 [[Call]]) | `"function"`                                                 |
| 其他任何对象                                                 | `"object"`                                                   |

**一定需要注意的是 typeof 的返回值以及 判断值 都是小写的 ，而且要带双引号**

实例

```javascript
// 数值
typeof 37 === 'number';

// 字符串
typeof '' === 'string';
typeof 'bla' === 'string';

// 布尔值
typeof true === 'boolean';

// Symbols
typeof Symbol() === 'symbol';

// Undefined
typeof undefined === 'undefined';

// 对象
typeof {a: 1} === 'object';

// 函数
typeof function() {} === 'function';
typeof class C {} === 'function'
typeof Math.sin === 'function';
```







### 12、链表的相关操作、api

**一般的leecode 算法经常先将链表转为数组**

```javascript
s = s.split('')
```

**String.prototype.split()**

`split() `方法使用指定的分隔符字符串将一个[`String`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String)对象分割成子字符串数组，以一个指定的分割字串来决定每个拆分的位置。 

<iframe class="interactive interactive-js" width="100%" height="250" src="https://interactive-examples.mdn.mozilla.net/pages/js/string-split.html" title="MDN Web Docs Interactive Example" loading="lazy" style="box-sizing: border-box; background-color: rgb(238, 238, 238); border: 0px; color: rgb(33, 33, 33); height: 490px; padding: 10px; width: 1002px;"></iframe>





**最后讲数组又转会为 数组**

```javascript
s = s.join('')
```



**Array.prototype.join()**

**join()** 方法将一个数组（或一个[类数组对象](https://developer.mozilla.org/zh-CN_docs/Web/JavaScript/Guide/Indexed_collections#working_with_array-like_objects)）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。

<iframe class="interactive interactive-js" width="100%" height="250" src="https://interactive-examples.mdn.mozilla.net/pages/js/array-join.html" title="MDN Web Docs Interactive Example" loading="lazy" style="box-sizing: border-box; background-color: rgb(238, 238, 238); border: 0px; color: rgb(33, 33, 33); height: 490px; padding: 10px; width: 1002px;"></iframe>



```
arr.join([separator])
```

**[参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/join#parameters)**

- `separator` 可选

  指定一个字符串来分隔数组的每个元素。如果需要，将分隔符转换为字符串。如果缺省该值，数组元素用逗号（`,`）分隔。如果`separator`是空字符串(`""`)，则所有元素之间都没有任何字符







**下面是 字符串一些常用的api**：

1. charAt(index)

      1）返回执行index序号位置上的字符

      2）index从0开始，最大到字符串的长度-1

      3）调用方式： 字符串.charAt(index)

   ![js字符串常用方法](https://exp-picture.cdn.bcebos.com/35f2224133bad341b7d75583427622bc7cc52c03.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1%2Fformat%2Cf_jpg%2Fquality%2Cq_80)

2. 

   indexOf(searchStr, startIndex)

      1）返回searchStr从startIndex序号开始往后在原字符串第一次出现的位置

      2）startIndex可以省略，默认为0，表示从前到后逐个搜索

      3）index从0开始，所以，最终的返回结果序号也是从0开始的，比如首字母就匹配到了，返回结果是0

      4）searchStr搜索字符串在原字符串中匹配是区分大小写的

      5）调用方式： 字符串.indexOf("待搜索字符串", 起始搜索位置)

   ![js字符串常用方法](https://exp-picture.cdn.bcebos.com/04d7a614f4d0b5030878f24acc4ec28332bf2003.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1%2Fformat%2Cf_jpg%2Fquality%2Cq_80)

3. 

   lastIndexOf(searchStr, startIndex)

      1）与indexOf方法类似，只是indexOf是左往右找第一个匹配的序号。lastIndexOf是从右往左找第一个匹配的序号

      2）lastIndexOf返回的序号仍然是从左往右开始计数的

   ![js字符串常用方法](https://exp-picture.cdn.bcebos.com/b57fb6db574afa325f36984354b2dc19cf2c1403.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1%2Fformat%2Cf_jpg%2Fquality%2Cq_80)

4. 

   substring(start, end)

      1）字符串截取，从start开始截取到序号为end之间的字符串

      2）序号从0开始计数，即首字母的序号是0

      3）end的最大值=字符串长度-1

      4）end是可以省略的，表示到字符串末尾

      5）调用方式： 字符串.substring(1, (字符串长度-1))

   ![js字符串常用方法](https://exp-picture.cdn.bcebos.com/1f9feadca039131f1846676de275f2c4ed990a03.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1%2Fformat%2Cf_jpg%2Fquality%2Cq_80)

5. 

   substr(start, length)

      1）功能与substring一样，都是截取字符串

      2）substr从start序号开始，截取length个字符串

      3）序号从0开始计数，length可以省略，表示到字符串末尾

      4）调用方式： 字符串.substr(start, length)

   ![js字符串常用方法](https://exp-picture.cdn.bcebos.com/49bf00425d6b04d1a8832e3cb213e8e5edee0103.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1%2Fformat%2Cf_jpg%2Fquality%2Cq_80)

6. 

   split(separator)

      1）将字符串分隔为数组，通常用于将逗号分隔的字符串转换为数组

      2）调用方式： 字符串.split(",")

   ![js字符串常用方法](https://exp-picture.cdn.bcebos.com/03605157935653bb098ad04f1d0b312104617103.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1%2Fformat%2Cf_jpg%2Fquality%2Cq_80)

7. 

   replace(正则或者搜索子字符串，新子字符串)

      1）如果是正则，则将原字符串的所有匹配子字符串替换为新子字符串，并返回新的字符串

      2）如果是搜索子字符串，则替换从前到后第一个匹配的子字符串为新子字符串，并返回新的字符串

      3）调用方式： 字符串.(正则或者搜索子字符串，新子字符串)

   ![js字符串常用方法](https://exp-picture.cdn.bcebos.com/e1390a31dfb6326c57cd2d7b89532f6322856003.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1%2Fformat%2Cf_jpg%2Fquality%2Cq_80)

### 13、字符串去除空格



**JavaScript trim() 方法**

**实例**

```javascript
去除字符串的头尾空格:

var str = "       Runoob        "; 
alert(str.trim());

输出结果:

Runoob
```





### 14、Map Set 常用api

**[使用 `Map` 对象](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map#使用_map_对象)**

```javascript
let myMap = new Map();

let keyObj = {};
let keyFunc = function() {};
let keyString = 'a string';

// 添加键
myMap.set(keyString, "和键'a string'关联的值");
myMap.set(keyObj, "和键keyObj关联的值");
myMap.set(keyFunc, "和键keyFunc关联的值");

myMap.size; // 3

// 读取值
myMap.get(keyString);    // "和键'a string'关联的值"
myMap.get(keyObj);       // "和键keyObj关联的值"
myMap.get(keyFunc);      // "和键keyFunc关联的值"

myMap.get('a string');   // "和键'a string'关联的值"
                         // 因为keyString === 'a string'
myMap.get({});           // undefined, 因为keyObj !== {}
myMap.get(function() {}); // undefined, 因为keyFunc !== function () {}
//判断是否含有
myMap.has(keyFunc);      // true

```

**[使用`Set`对象](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set#使用set对象)**

```javascript
let mySet = new Set();

mySet.add(1); // Set [ 1 ]
mySet.add(5); // Set [ 1, 5 ]
mySet.add(5); // Set [ 1, 5 ]
mySet.add("some text"); // Set [ 1, 5, "some text" ]
let o = {a: 1, b: 2};
mySet.add(o);

mySet.add({a: 1, b: 2}); // o 指向的是不同的对象，所以没问题

mySet.has(1); // true
mySet.has(3); // false
mySet.has(5);              // true
mySet.has(Math.sqrt(25));  // true
mySet.has("Some Text".toLowerCase()); // true
mySet.has(o); // true

mySet.size; // 5

mySet.delete(5);  // true,  从set中移除5
mySet.has(5);     // false, 5已经被移除

mySet.size; // 4, 刚刚移除一个值

console.log(mySet);
// logs Set(4) [ 1, "some text", {…}, {…} ] in Firefox
// logs Set(4) { 1, "some text", {…}, {…} } in Chrome
```





### 15、js常用排序算法

**想学好前端，先练好内功，只有内功深厚者，前端之路才会走得更远**。

笔者写的 **JavaScript 数据结构与算法之美** 系列用的语言是 **JavaScript** ，旨在入门数据结构与算法和方便以后复习。

之所以把`归并排序、快速排序、希尔排序、堆排序`放在一起比较，是因为它们的平均时间复杂度都为 **O(nlogn)**。

请大家带着问题：`快排和归并用的都是分治思想，递推公式和递归代码也非常相似，那它们的区别在哪里呢 ?` 来阅读下文。

**1. 归并排序（Merge Sort）**

**思想**

排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。

归并排序采用的是`分治思想`。

分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。



![merge-sort-example.png](https://user-gold-cdn.xitu.io/2019/7/23/16c1f400a4920693?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



> 注：x >> 1 是位运算中的右移运算，表示右移一位，等同于 x 除以 2 再取整，即 x >> 1 === Math.floor(x / 2) 。

**实现**

```
const mergeSort = arr => {
	//采用自上而下的递归方法
	const len = arr.length;
	if (len < 2) {
		return arr;
	}
	// length >> 1 和 Math.floor(len / 2) 等价
	let middle = Math.floor(len / 2),
		left = arr.slice(0, middle),
		right = arr.slice(middle); // 拆分为两个子数组
	return merge(mergeSort(left), mergeSort(right));
};

const merge = (left, right) => {
	const result = [];

	while (left.length && right.length) {
		// 注意: 判断的条件是小于或等于，如果只是小于，那么排序将不稳定.
		if (left[0] <= right[0]) {
			result.push(left.shift());
		} else {
			result.push(right.shift());
		}
	}

	while (left.length) result.push(left.shift());

	while (right.length) result.push(right.shift());

	return result;
};
复制代码
```

**测试**

```
// 测试
const arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];
console.time('归并排序耗时');
console.log('arr :', mergeSort(arr));
console.timeEnd('归并排序耗时');
// arr : [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
// 归并排序耗时: 0.739990234375ms
复制代码
```

**分析**

- 第一，归并排序是原地排序算法吗 ？ 这是因为归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。 实际上，尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 O(n)。 所以，归并排序不是原地排序算法。
- 第二，归并排序是稳定的排序算法吗 ？ merge 方法里面的 left[0] <= right[0] ，保证了值相同的元素，在合并前后的先后顺序不变。归并排序是一种稳定的排序方法。
- 第三，归并排序的时间复杂度是多少 ？ 从效率上看，归并排序可算是排序算法中的`佼佼者`。假设数组长度为 n，那么拆分数组共需 logn 步, 又每步都是一个普通的合并子数组的过程，时间复杂度为 O(n)，故其综合时间复杂度为 O(nlogn)。 最佳情况：T(n) = O(nlogn)。 最差情况：T(n) = O(nlogn)。 平均情况：T(n) = O(nlogn)。

**动画**



![merge-sort.gif](https://user-gold-cdn.xitu.io/2019/7/23/16c1f400a943f4fc?imageslim)



**2. 快速排序 （Quick Sort）**

快速排序的特点就是快，而且效率高！它是处理大数据最快的排序算法之一。

**思想**

- 先找到一个基准点（一般指数组的中部），然后数组被该基准点分为两部分，依次与该基准点数据比较，如果比它小，放左边；反之，放右边。
- 左右分别用一个空数组去存储比较后的数据。
- 最后递归执行上述操作，直到数组长度 <= 1;

特点：快速，常用。

缺点：需要另外声明两个数组，浪费了内存空间资源。

**实现**

方法一：

```javascript
const quickSort1 = arr => {
	if (arr.length <= 1) {
		return arr;
	}
	//取基准点
	const midIndex = Math.floor(arr.length / 2);
	//取基准点的值，splice(index,1) 则返回的是含有被删除的元素的数组。
	const valArr = arr.splice(midIndex, 1);
	const midIndexVal = valArr[0];
	const left = []; //存放比基准点小的数组
	const right = []; //存放比基准点大的数组
	//遍历数组，进行判断分配
	for (let i = 0; i < arr.length; i++) {
		if (arr[i] < midIndexVal) {
			left.push(arr[i]); //比基准点小的放在左边数组
		} else {
			right.push(arr[i]); //比基准点大的放在右边数组
		}
	}
	//递归执行以上操作，对左右两个数组进行操作，直到数组长度为 <= 1
	return quickSort1(left).concat(midIndexVal, quickSort1(right));
};
const array2 = [5, 4, 3, 2, 1];
console.log('quickSort1 ', quickSort1(array2));
// quickSort1: [1, 2, 3, 4, 5]
复制代码
```

方法二：

```javascript
// 快速排序
const quickSort = (arr, left, right) => {
	let len = arr.length,
		partitionIndex;
	left = typeof left != 'number' ? 0 : left;
	right = typeof right != 'number' ? len - 1 : right;

	if (left < right) {
		partitionIndex = partition(arr, left, right);
		quickSort(arr, left, partitionIndex - 1);
		quickSort(arr, partitionIndex + 1, right);
	}
	return arr;
};

const partition = (arr, left, right) => {
	//分区操作
	let pivot = left, //设定基准值（pivot）
		index = pivot + 1;
	for (let i = index; i <= right; i++) {
		if (arr[i] < arr[pivot]) {
			swap(arr, i, index);
			index++;
		}
	}
	swap(arr, pivot, index - 1);
	return index - 1;
};

const swap = (arr, i, j) => {
	let temp = arr[i];
	arr[i] = arr[j];
	arr[j] = temp;
};
复制代码
```

测试

```javascript
// 测试
const array = [5, 4, 3, 2, 1];
console.log('原始array:', array);
const newArr = quickSort(array);
console.log('newArr:', newArr);
// 原始 array:  [5, 4, 3, 2, 1]
// newArr:     [1, 4, 3, 2, 5]
复制代码
```

**分析**

- 第一，快速排序是原地排序算法吗 ？ 因为 partition() 函数进行分区时，不需要很多额外的内存空间，所以快排是`原地排序`算法。
- 第二，快速排序是稳定的排序算法吗 ？ 和选择排序相似，快速排序每次交换的元素都有可能不是相邻的，因此它有可能打破原来值为相同的元素之间的顺序。因此，快速排序并不稳定。
- 第三，快速排序的时间复杂度是多少 ？ 极端的例子：如果数组中的数据原来已经是有序的了，比如 1，3，5，6，8。如果我们每次选择最后一个元素作为 pivot，那每次分区得到的两个区间都是不均等的。我们需要进行大约 n 次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约 n / 2 个元素，这种情况下，快排的时间复杂度就从 O(nlogn) 退化成了 O(n2)。 最佳情况：T(n) = O(nlogn)。 最差情况：T(n) = O(n2)。 平均情况：T(n) = O(nlogn)。

**动画**



![quick-sort.gif](https://user-gold-cdn.xitu.io/2019/7/23/16c1f400a959d098?imageslim)



**解答开篇问题**

快排和归并用的都是分治思想，递推公式和递归代码也非常相似，那它们的区别在哪里呢 ？



![快速排序与归并排序](https://user-gold-cdn.xitu.io/2019/7/23/16c1f400af40f991?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



可以发现：

- 归并排序的处理过程是`由下而上`的，先处理子问题，然后再合并。
- 而快排正好相反，它的处理过程是`由上而下`的，先分区，然后再处理子问题。
- 归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。
- 归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。
- 快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。

**3. 希尔排序（Shell Sort）**

**思想**

- 先将整个待排序的记录序列分割成为若干子序列。
- 分别进行直接插入排序。
- 待整个序列中的记录基本有序时，再对全体记录进行依次直接插入排序。

**过程**

1. 举个易于理解的例子：[35, 33, 42, 10, 14, 19, 27, 44]，我们采取间隔 4。创建一个位于 4 个位置间隔的所有值的虚拟子列表。下面这些值是 { 35, 14 }，{ 33, 19 }，{ 42, 27 } 和 { 10, 44 }。



![栗子](https://user-gold-cdn.xitu.io/2019/7/23/16c1f400c7272496?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



1. 我们比较每个子列表中的值，并在原始数组中交换它们（如果需要）。完成此步骤后，新数组应如下所示。



![栗子](https://user-gold-cdn.xitu.io/2019/7/23/16c1f400d228f608?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



1. 然后，我们采用 2 的间隔，这个间隙产生两个子列表：{ 14, 27, 35, 42 }， { 19, 10, 33, 44 }。



![栗子](https://user-gold-cdn.xitu.io/2019/7/23/16c1f400d8c0378c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



1. 我们比较并交换原始数组中的值（如果需要）。完成此步骤后，数组变成：[14, 10, 27, 19, 35, 33, 42, 44]，图如下所示，10 与 19 的位置互换一下。



![image.png](https://user-gold-cdn.xitu.io/2019/7/23/16c1f400deeea4b2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



1. 最后，我们使用值间隔 1 对数组的其余部分进行排序，Shell sort 使用插入排序对数组进行排序。



![栗子](https://user-gold-cdn.xitu.io/2019/7/23/16c1f400f86526f4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



**实现**

```
const shellSort = arr => {
	let len = arr.length,
		temp,
		gap = 1;
	console.time('希尔排序耗时');
	while (gap < len / 3) {
		//动态定义间隔序列
		gap = gap * 3 + 1;
	}
	for (gap; gap > 0; gap = Math.floor(gap / 3)) {
		for (let i = gap; i < len; i++) {
			temp = arr[i];
			let j = i - gap;
			for (; j >= 0 && arr[j] > temp; j -= gap) {
				arr[j + gap] = arr[j];
			}
			arr[j + gap] = temp;
			console.log('arr  :', arr);
		}
	}
	console.timeEnd('希尔排序耗时');
	return arr;
};
复制代码
```

测试

```
// 测试
const array = [35, 33, 42, 10, 14, 19, 27, 44];
console.log('原始array:', array);
const newArr = shellSort(array);
console.log('newArr:', newArr);
// 原始 array:   [35, 33, 42, 10, 14, 19, 27, 44]
// arr      :   [14, 33, 42, 10, 35, 19, 27, 44]
// arr      :   [14, 19, 42, 10, 35, 33, 27, 44]
// arr      :   [14, 19, 27, 10, 35, 33, 42, 44]
// arr      :   [14, 19, 27, 10, 35, 33, 42, 44]
// arr      :   [14, 19, 27, 10, 35, 33, 42, 44]
// arr      :   [14, 19, 27, 10, 35, 33, 42, 44]
// arr      :   [10, 14, 19, 27, 35, 33, 42, 44]
// arr      :   [10, 14, 19, 27, 35, 33, 42, 44]
// arr      :   [10, 14, 19, 27, 33, 35, 42, 44]
// arr      :   [10, 14, 19, 27, 33, 35, 42, 44]
// arr      :   [10, 14, 19, 27, 33, 35, 42, 44]
// 希尔排序耗时: 3.592041015625ms
// newArr:     [10, 14, 19, 27, 33, 35, 42, 44]
复制代码
```

**分析**

- 第一，希尔排序是原地排序算法吗 ？ 希尔排序过程中，只涉及相邻数据的交换操作，只需要常量级的临时空间，空间复杂度为 O(1) 。所以，希尔排序是`原地排序`算法。
- 第二，希尔排序是稳定的排序算法吗 ？ 我们知道，单次直接插入排序是稳定的，它不会改变相同元素之间的相对顺序，但在多次不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，可能导致相同元素相对顺序发生变化。 因此，希尔排序`不稳定`。
- 第三，希尔排序的时间复杂度是多少 ？ 最佳情况：T(n) = O(n logn)。 最差情况：T(n) = O(n (log(n))2)。 平均情况：T(n) = 取决于间隙序列。

**动画**



![shell-sort.gif](https://user-gold-cdn.xitu.io/2019/7/23/16c1f400f870146a?imageslim)



**4. 堆排序（Heap Sort）**

**堆的定义**

堆其实是一种特殊的树。只要满足这两点，它就是一个堆。

- 堆是一个完全二叉树。 完全二叉树：除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。
- 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。 也可以说：堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值。这两种表述是等价的。

对于每个节点的值都`大于等于`子树中每个节点值的堆，我们叫作`大顶堆`。 对于每个节点的值都`小于等于`子树中每个节点值的堆，我们叫作`小顶堆`。



![区分堆、大顶堆、小顶堆](https://user-gold-cdn.xitu.io/2019/7/23/16c1f40107bab9d0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



其中图 1 和 图 2 是大顶堆，图 3 是小顶堆，图 4 不是堆。除此之外，从图中还可以看出来，对于同一组数据，我们可以构建多种不同形态的堆。

**思想**

1. 将初始待排序关键字序列 (R1, R2 .... Rn) 构建成大顶堆，此堆为初始的无序区；
2. 将堆顶元素 R[1] 与最后一个元素 R[n] 交换，此时得到新的无序区 (R1, R2, ..... Rn-1) 和新的有序区 (Rn) ，且满足 R[1, 2 ... n-1] <= R[n]。
3. 由于交换后新的堆顶 R[1] 可能违反堆的性质，因此需要对当前无序区 (R1, R2 ...... Rn-1) 调整为新堆，然后再次将 R[1] 与无序区最后一个元素交换，得到新的无序区 (R1, R2 .... Rn-2) 和新的有序区 (Rn-1, Rn)。不断重复此过程，直到有序区的元素个数为 n - 1，则整个排序过程完成。

**实现**

```
// 堆排序
const heapSort = array => {
	console.time('堆排序耗时');
	// 初始化大顶堆，从第一个非叶子结点开始
	for (let i = Math.floor(array.length / 2 - 1); i >= 0; i--) {
		heapify(array, i, array.length);
	}
	// 排序，每一次 for 循环找出一个当前最大值，数组长度减一
	for (let i = Math.floor(array.length - 1); i > 0; i--) {
		// 根节点与最后一个节点交换
		swap(array, 0, i);
		// 从根节点开始调整，并且最后一个结点已经为当前最大值，不需要再参与比较，所以第三个参数为 i，即比较到最后一个结点前一个即可
		heapify(array, 0, i);
	}
	console.timeEnd('堆排序耗时');
	return array;
};

// 交换两个节点
const swap = (array, i, j) => {
	let temp = array[i];
	array[i] = array[j];
	array[j] = temp;
};

// 将 i 结点以下的堆整理为大顶堆，注意这一步实现的基础实际上是：
// 假设结点 i 以下的子堆已经是一个大顶堆，heapify 函数实现的
// 功能是实际上是：找到 结点 i 在包括结点 i 的堆中的正确位置。
// 后面将写一个 for 循环，从第一个非叶子结点开始，对每一个非叶子结点
// 都执行 heapify 操作，所以就满足了结点 i 以下的子堆已经是一大顶堆
const heapify = (array, i, length) => {
	let temp = array[i]; // 当前父节点
	// j < length 的目的是对结点 i 以下的结点全部做顺序调整
	for (let j = 2 * i + 1; j < length; j = 2 * j + 1) {
		temp = array[i]; // 将 array[i] 取出，整个过程相当于找到 array[i] 应处于的位置
		if (j + 1 < length && array[j] < array[j + 1]) {
			j++; // 找到两个孩子中较大的一个，再与父节点比较
		}
		if (temp < array[j]) {
			swap(array, i, j); // 如果父节点小于子节点:交换；否则跳出
			i = j; // 交换后，temp 的下标变为 j
		} else {
			break;
		}
	}
};
复制代码
```

测试

```
const array = [4, 6, 8, 5, 9, 1, 2, 5, 3, 2];
console.log('原始array:', array);
const newArr = heapSort(array);
console.log('newArr:', newArr);
// 原始 array:  [4, 6, 8, 5, 9, 1, 2, 5, 3, 2]
// 堆排序耗时: 0.15087890625ms
// newArr:     [1, 2, 2, 3, 4, 5, 5, 6, 8, 9]
复制代码
```

**分析**

- 第一，堆排序是原地排序算法吗 ？ 整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是原地排序算法。
- 第二，堆排序是稳定的排序算法吗 ？ 因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。 所以，堆排序是`不稳定`的排序算法。
- 第三，堆排序的时间复杂度是多少 ？ 堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 O(n)，排序过程的时间复杂度是 O(nlogn)，所以，堆排序整体的时间复杂度是 O(nlogn)。 最佳情况：T(n) = O(nlogn)。 最差情况：T(n) = O(nlogn)。 平均情况：T(n) = O(nlogn)。

**动画**



![heap-sort.gif](https://user-gold-cdn.xitu.io/2019/7/23/16c1f40108015de8?imageslim)





![heap-sort2.gif](https://user-gold-cdn.xitu.io/2019/7/23/16c1f4011e30a700?imageslim)



**5. 排序算法的复杂性对比**

**复杂性对比**

| 名称     | 最好    | 平均           | 最坏       | 内存   | 稳定性 | 备注                                           |
| -------- | ------- | -------------- | ---------- | ------ | ------ | ---------------------------------------------- |
| 归并排序 | nlog(n) | nlog(n)        | nlog(n)    | n      | Yes    | ...                                            |
| 快速排序 | nlog(n) | nlog(n)        | n2         | log(n) | No     | 在 in-place 版本下，内存复杂度通常是 O(log(n)) |
| 希尔排序 | nlog(n) | 取决于差距序列 | n(log(n))2 | 1      | No     | ...                                            |
| 堆排序   | nlog(n) | nlog(n)        | nlog(n)    | 1      | No     | ...                                            |

**算法可视化工具**

- 算法可视化工具 [algorithm-visualizer](https://github.com/algorithm-visualizer/algorithm-visualizer) 算法可视化工具 algorithm-visualizer 是一个交互式的在线平台，可以从代码中可视化算法，还可以看到代码执行的过程。

效果如下图。



![算法可视化工具](https://user-gold-cdn.xitu.io/2019/7/21/16c1387a2ed590b8?imageslim)



旨在通过交互式可视化的执行来揭示算法背后的机制。

- 算法可视化来源 [visualgo.net/en](https://visualgo.net/en) 效果如下图。

  ![quick-sort.gif](https://user-gold-cdn.xitu.io/2019/7/23/16c1f4012b0cdf58?imageslim)

  

- [www.ee.ryerson.ca](https://www.ee.ryerson.ca/~courses/coe428/sorting/insertionsort.html)



![insert-sort.gif](https://user-gold-cdn.xitu.io/2019/7/23/16c1f4013114ab49?imageslim)



- [illustrated-algorithms](https://github.com/skidding/illustrated-algorithms)

  变量和操作的可视化表示增强了控制流和实际源代码。您可以快速前进和后退执行，以密切观察算法的工作方式。





### 16、常用的Math 方法

![1620827205(1)](https://z3.ax1x.com/2021/05/12/g0mteK.png)



### 17、什么是回调地狱

**浅谈：从回调地狱到Promise（三个实例方法，两个对象方法）**

**一.回调地狱的形成**

如果一个请求b需要在拿到请求a中返回的参数后，才能正确发起请求，用传统的Ajax处理会有回调地狱的问题，及层层嵌套问题，代码不易读，后期亦不好维护。

```javascript
function sayNum(name, callback) {
        setTimeout(() => {
            console.log(name);
            callback()
        }, 1000)
    }
    sayNum('one', function () {
        sayNum('two', function () {
            sayNum('three', function () {
                sayNum('four', function () {
                    console.log('结束了');
                })
            })
        })
    })
//打印结果 one two three four 结束了
复制代码
```

**二.Promise是如何解决回调地狱问题的**

Promise是避免回调地狱的一个进步，通过.then( )的链式操作来触发多个异步任务，并且保证执行顺序，使得代码更易于阅读和维护。

怎么样，经过Promise化后，代码是不是看起来清晰多了。

```javascript
function fn(num) {
        return new Promise(function (resolve, reject) {
            setTimeout(() => {
                console.log(num);
                resolve(num)
            }, 1000)
        })
    }
    
    var p1 = fn('one')
    p1.then((data) => {
            return fn('two')
        })
        .then((data) => {
            return fn('three')
        })
        .then((data) => {
            return fn('four')
        })
//  打印结果  one two three four
复制代码
```

**Promise的三个实例方法**

resolve和reject两个回调函数分别隐射为Promise.then( )和Promise.catch( )，值得注意的是Promise还有第三个实例方法Promise.finally( )，无论成功与否都会触发

**.then( )参数中的函数返回值：**

1. 返回promise实例对象： 返回的实例对象会调用下一个then
2. 返回普通值： 如果.then返回的不是promise实例对象，而是一个普通值，那么这个then会返回一个默认的promise对象，从而保证能继续进行链式操作

**Promise的两个对象方法：**

Promise.all( )： 并发处理多个异步任务，所有任务都执行完成才能得到结果，并发处理的任务都是按照顺序执行的

```
        var p1 = fn('第一次')
        var p2 = fn('第二次')
        var p3 = fn('第三次')
        
        Promise.all([p1, p2, p3]).then((res) => {
            console.log(res);
        })
//  打印   ['第一次','第二次','第三次']
复制代码
```

Promise.race( )：并发处理多个异步任务，只要有一个任务完成就能得到结果

```
        var p1 = fn('第一次')
        var p2 = fn('第二次')
        var p3 = fn('第三次')
        
        Promise.all([p1, p2, p3]).then((res) => {
            console.log(res);
        })
//  打印   第一次
```



### 18、async、await







### 19、





### 20、



### 21、



### 22、



### 23、



### 24、



### 25、



### 26、



### 27、



### 28、



### 29、











